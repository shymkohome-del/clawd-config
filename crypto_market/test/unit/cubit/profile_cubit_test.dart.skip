import 'dart:io';
import 'dart:typed_data';
import 'package:bloc_test/bloc_test.dart';
import 'package:crypto_market/core/blockchain/errors.dart';
import 'package:crypto_market/features/auth/cubit/profile_cubit.dart';
import 'package:crypto_market/features/auth/models/user_profile.dart';
import 'package:crypto_market/features/auth/providers/user_service_provider.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';

class MockUserService extends Mock implements UserService {}

class MockFile extends Mock implements File {}

class FakeUserUpdate extends Fake implements UserUpdate {}

void main() {
  group('ProfileCubit Unit Tests', () {
    late MockUserService mockUserService;
    late ProfileCubit profileCubit;

    const testPrincipal = 'principal-test123';
    final testProfile = UserProfile(
      id: testPrincipal,
      email: 'test@example.com',
      username: 'testuser',
      authProvider: 'email',
      createdAtMillis: DateTime.now().millisecondsSinceEpoch,
      reputation: 100,
      kycVerified: false,
    );

    setUpAll(() {
      registerFallbackValue(FakeUserUpdate());
    });

    setUp(() {
      mockUserService = MockUserService();
      profileCubit = ProfileCubit(mockUserService);
    });

    tearDown(() {
      profileCubit.close();
    });

    group('loadProfile', () {
      blocTest<ProfileCubit, ProfileState>(
        'should emit [ProfileLoading, ProfileLoaded] when successful',
        build: () {
          when(
            () => mockUserService.getUserProfile(testPrincipal),
          ).thenAnswer((_) async => Result.ok(testProfile));
          return ProfileCubit(mockUserService);
        },
        act: (cubit) => cubit.loadProfile(testPrincipal),
        expect: () => [ProfileLoading(), ProfileLoaded(testProfile)],
        verify: (cubit) {
          verify(() => mockUserService.getUserProfile(testPrincipal)).called(1);
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should emit [ProfileLoading, ProfileError] when service fails',
        build: () {
          when(
            () => mockUserService.getUserProfile(testPrincipal),
          ).thenAnswer((_) async => Result.err(AuthError.network));
          return ProfileCubit(mockUserService);
        },
        act: (cubit) => cubit.loadProfile(testPrincipal),
        expect: () => [ProfileLoading(), ProfileError(AuthError.network)],
        verify: (cubit) {
          verify(() => mockUserService.getUserProfile(testPrincipal)).called(1);
        },
      );
    });

    group('updateProfile', () {
      blocTest<ProfileCubit, ProfileState>(
        'should emit error when not in ProfileLoaded state',
        build: () => ProfileCubit(mockUserService),
        seed: () => ProfileInitial(),
        act: (cubit) => cubit.updateProfile(
          principal: testPrincipal,
          username: 'newusername',
        ),
        expect: () => [ProfileError(AuthError.unknown)],
        verify: (cubit) {
          verifyNever(() => mockUserService.updateUserProfile(any(), any()));
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should update username successfully',
        build: () {
          when(
            () => mockUserService.updateUserProfile(any(), any()),
          ).thenAnswer(
            (_) async =>
                Result.ok(testProfile.copyWith(username: 'newusername')),
          );
          return ProfileCubit(mockUserService);
        },
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.updateProfile(
          principal: testPrincipal,
          username: 'newusername',
        ),
        expect: () => [
          ProfileUpdating(testProfile),
          ProfileLoaded(testProfile.copyWith(username: 'newusername')),
          ProfileUpdateSuccess(testProfile.copyWith(username: 'newusername')),
        ],
        verify: (cubit) {
          verify(
            () => mockUserService.updateUserProfile(
              testPrincipal,
              any(
                that: predicate<UserUpdate>(
                  (update) =>
                      update.username == 'newusername' &&
                      update.profileImage == null,
                ),
              ),
            ),
          ).called(1);
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should handle profile image upload and update',
        build: () {
          final mockFile = MockFile();
          when(
            () => mockUserService.uploadImageFileToIPFS(mockFile),
          ).thenAnswer((_) async => Result.ok('QmTestHash123'));
          when(
            () => mockUserService.updateUserProfile(any(), any()),
          ).thenAnswer(
            (_) async =>
                Result.ok(testProfile.copyWith(profileImage: 'QmTestHash123')),
          );
          return ProfileCubit(mockUserService);
        },
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.updateProfile(
          principal: testPrincipal,
          profileImage: MockFile(),
        ),
        expect: () => [
          ProfileUpdating(testProfile),
          ProfileLoaded(testProfile.copyWith(profileImage: 'QmTestHash123')),
          ProfileUpdateSuccess(
            testProfile.copyWith(profileImage: 'QmTestHash123'),
          ),
        ],
        verify: (cubit) {
          verify(() => mockUserService.uploadImageFileToIPFS(any())).called(1);
          verify(
            () => mockUserService.updateUserProfile(
              testPrincipal,
              any(
                that: predicate<UserUpdate>(
                  (update) =>
                      update.profileImage == 'QmTestHash123' &&
                      update.username == null,
                ),
              ),
            ),
          ).called(1);
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should handle image upload failure',
        build: () {
          final mockFile = MockFile();
          when(
            () => mockUserService.uploadImageFileToIPFS(mockFile),
          ).thenAnswer((_) async => Result.err(AuthError.network));
          return ProfileCubit(mockUserService);
        },
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.updateProfile(
          principal: testPrincipal,
          profileImage: MockFile(),
        ),
        expect: () => [
          ProfileUpdating(testProfile),
          ProfileError(AuthError.network),
        ],
        verify: (cubit) {
          verify(() => mockUserService.uploadImageFileToIPFS(any())).called(1);
          verifyNever(() => mockUserService.updateUserProfile(any(), any()));
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should return to loaded state when no changes made',
        build: () => ProfileCubit(mockUserService),
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.updateProfile(
          principal: testPrincipal,
          // No username or profileImage provided
        ),
        expect: () => [ProfileLoaded(testProfile)],
        verify: (cubit) {
          verifyNever(() => mockUserService.updateUserProfile(any(), any()));
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should handle profile update service failure',
        build: () {
          when(
            () => mockUserService.updateUserProfile(any(), any()),
          ).thenAnswer((_) async => Result.err(AuthError.invalidCredentials));
          return ProfileCubit(mockUserService);
        },
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.updateProfile(
          principal: testPrincipal,
          username: 'newusername',
        ),
        expect: () => [
          ProfileUpdating(testProfile),
          ProfileError(AuthError.invalidCredentials),
        ],
        verify: (cubit) {
          verify(
            () => mockUserService.updateUserProfile(any(), any()),
          ).called(1);
        },
      );
    });

    group('uploadProfileImage', () {
      final testImageData = Uint8List.fromList([1, 2, 3, 4, 5]);

      blocTest<ProfileCubit, ProfileState>(
        'should emit error when not in ProfileLoaded state',
        build: () => ProfileCubit(mockUserService),
        seed: () => ProfileInitial(),
        act: (cubit) => cubit.uploadProfileImage(
          principal: testPrincipal,
          imageData: testImageData,
        ),
        expect: () => [ProfileError(AuthError.unknown)],
        verify: (cubit) {
          verifyNever(() => mockUserService.uploadImageToIPFS(any()));
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should upload image and update profile successfully',
        build: () {
          when(
            () => mockUserService.uploadImageToIPFS(testImageData),
          ).thenAnswer((_) async => Result.ok('QmNewHash456'));
          when(
            () => mockUserService.updateUserProfile(any(), any()),
          ).thenAnswer(
            (_) async =>
                Result.ok(testProfile.copyWith(profileImage: 'QmNewHash456')),
          );
          return ProfileCubit(mockUserService);
        },
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.uploadProfileImage(
          principal: testPrincipal,
          imageData: testImageData,
        ),
        expect: () => [
          ProfileUpdating(testProfile),
          ProfileLoaded(testProfile.copyWith(profileImage: 'QmNewHash456')),
          ProfileUpdateSuccess(
            testProfile.copyWith(profileImage: 'QmNewHash456'),
          ),
        ],
        verify: (cubit) {
          verify(
            () => mockUserService.uploadImageToIPFS(testImageData),
          ).called(1);
          verify(
            () => mockUserService.updateUserProfile(
              testPrincipal,
              any(
                that: predicate<UserUpdate>(
                  (update) => update.profileImage == 'QmNewHash456',
                ),
              ),
            ),
          ).called(1);
        },
      );

      blocTest<ProfileCubit, ProfileState>(
        'should handle image upload failure',
        build: () {
          when(
            () => mockUserService.uploadImageToIPFS(testImageData),
          ).thenAnswer((_) async => Result.err(AuthError.network));
          return ProfileCubit(mockUserService);
        },
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.uploadProfileImage(
          principal: testPrincipal,
          imageData: testImageData,
        ),
        expect: () => [
          ProfileUpdating(testProfile),
          ProfileError(AuthError.network),
        ],
        verify: (cubit) {
          verify(
            () => mockUserService.uploadImageToIPFS(testImageData),
          ).called(1);
          verifyNever(() => mockUserService.updateUserProfile(any(), any()));
        },
      );
    });

    group('utility methods', () {
      blocTest<ProfileCubit, ProfileState>(
        'clearError should reset from error state to initial',
        build: () => ProfileCubit(mockUserService),
        seed: () => ProfileError(AuthError.network),
        act: (cubit) => cubit.clearError(),
        expect: () => [ProfileInitial()],
      );

      blocTest<ProfileCubit, ProfileState>(
        'clearError should not change non-error states',
        build: () => ProfileCubit(mockUserService),
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.clearError(),
        expect: () => [],
      );

      blocTest<ProfileCubit, ProfileState>(
        'reset should emit initial state',
        build: () => ProfileCubit(mockUserService),
        seed: () => ProfileLoaded(testProfile),
        act: (cubit) => cubit.reset(),
        expect: () => [ProfileInitial()],
      );
    });
  });
}

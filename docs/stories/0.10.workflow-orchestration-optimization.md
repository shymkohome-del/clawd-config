Title: Story 0.10 — Workflow Orchestration Optimization and Cost Reduction
Status: Backlog

# Story 0.10: Intelligent Workflow Orchestration with Path-Based Filtering and Sequential Execution

## Story

As a repository maintainer, I want our GitHub Actions workflows to be cost-efficient, targeted, and context-aware, so that developers get fast feedback without unnecessary resource consumption, and QA workflows only run when needed.

## Problem Statement

Currently, when a developer pushes to a story branch, multiple workflows trigger simultaneously regardless of file changes, causing:
- **Resource Waste**: Flutter CI runs on documentation-only changes
- **Parallel Inefficiency**: 3+ workflows run concurrently (75+ minutes of runner time per push)
- **Redundant Execution**: Same validations run on branch push AND PR creation
- **Poor Developer Experience**: Long wait times for simple changes
- **High Costs**: Estimated 60-70% of workflow runs are unnecessary

## Business Impact

- **Current Cost**: ~30-75 minutes of runner time per push
- **Target Reduction**: 70-80% cost savings through smart orchestration
- **Developer Productivity**: Reduce wait time from 75 minutes to ~10 minutes for relevant changes
- **Resource Efficiency**: Zero workflows for documentation-only changes

## Acceptance Criteria

### AC1: Path-Based Filtering Implementation
- **Given** a push contains only documentation changes (`.md`, `docs/**`)
- **When** the workflow orchestrator analyzes the changes
- **Then** no Flutter CI or expensive workflows execute [Source: docs/architecture/github-actions-orchestration.md#cost-optimization]
- **And** only relevant linting workflows run if needed

### AC2: Sequential Workflow Execution
- **Given** a push contains Flutter code changes
- **When** the workflow orchestrator runs
- **Then** workflows execute in optimal sequence: Lint → Test → Build → Deploy [Source: docs/architecture/workflow-orchestration-execution-plan.md#sequential-execution]
- **And** expensive operations (Flutter CI) only run after cheap validations pass

### AC3: Smart Workflow Selection
- **Given** different types of file changes
- **When** the orchestrator analyzes the changeset
- **Then** only relevant workflows execute: [Source: docs/architecture/workflow-orchestration-execution-plan.md#path-filtering]
  - `.dart` files → Flutter CI
  - `.github/workflows/**` → Workflow Lint only
  - `docs/**` → Documentation validation only
  - `README.md` → No workflows

### AC4: Early Failure Termination
- **Given** a basic validation fails (e.g., YAML lint)
- **When** the sequential workflow is running
- **Then** all downstream expensive operations are cancelled immediately [Source: docs/architecture/workflow-orchestration-execution-plan.md#early-failure-detection]
- **And** clear failure feedback is provided to developers

### AC5: Workflow Consolidation
- **Given** multiple workflows with overlapping triggers
- **When** the optimization is implemented
- **Then** redundant triggers are removed [Source: docs/architecture/github-workflow-optimization-analysis.md#redundant-execution]
- **And** a single orchestrator manages execution flow

## Dependencies

- 0.9 Epic (Automated PR and Auto-merge) - Complete [Source: docs/stories/0.9.epic-automated-pr-and-auto-merge.md]
- 0.1 Repo & CI baseline - Complete [Source: docs/stories/0.1.repo-and-ci-baseline.md]

## Tasks / Subtasks

### Phase 1: Immediate Optimizations (Cost Reduction 50-60%)
- [ ] **T1.1**: Add path-based filtering to `flutter-ci.yml` [Source: .github/workflows/flutter-ci.yml]
  - Filter paths: `crypto_market/**/*.dart`, `pubspec.yaml`, `pubspec.lock`
  - Remove redundant push triggers to `story/**` branches
- [ ] **T1.2**: Remove duplicate push triggers from `pr-lint.yml` [Source: .github/workflows/pr-lint.yml]
  - Only `auto-pr-from-qa.yml` should trigger on story branch pushes
- [ ] **T1.3**: Add conditional job execution in `auto-pr-from-qa.yml` [Source: .github/workflows/auto-pr-from-qa.yml]
  - Use path filtering to conditionally run Flutter CI
  - Skip expensive operations for non-code changes

### Phase 2: Orchestrator Implementation (Cost Reduction 70-80%)
- [ ] **T2.1**: Create master orchestrator workflow (`.github/workflows/story-orchestrator.yml`)
  - Analyze file changes using `dorny/paths-filter@v2`
  - Output flags for workflow categories (flutter, workflows, docs, tests)
- [ ] **T2.2**: Implement sequential job execution [Source: docs/architecture/workflow-orchestration-execution-plan.md#sequential-execution]
  - Chain workflows: `workflow-lint` → `preflight-parse` → `flutter-ci` → `create-pr`
  - Use `needs:` dependencies for proper sequencing
- [ ] **T2.3**: Replace existing triggers with orchestrator calls [Source: .github/workflows/reusable-auto-pr.yml]
  - Update all workflows to use `workflow_call` instead of direct triggers
  - Maintain backward compatibility during transition

### Phase 3: Advanced Optimizations
- [ ] **T3.1**: Implement intelligent concurrency groups
  - Group by story branch and commit SHA: `story-${{ github.ref }}-${{ github.sha }}`
  - Cancel in-progress runs for superseded commits
- [ ] **T3.2**: Add early failure detection and cancellation
  - Implement failure propagation across workflow chain
  - Add automated cleanup for cancelled workflows
- [ ] **T3.3**: Create workflow cost monitoring dashboard
  - Track GitHub Actions minutes consumption
  - Generate optimization reports and recommendations

### Phase 4: Validation and Documentation
- [ ] **T4.1**: Comprehensive testing across change types [Source: docs/architecture/workflow-orchestration-testing-plan.md]
  - Test documentation-only changes (expect 0 workflows)
  - Test Flutter changes (expect sequential execution)
  - Test mixed changes (expect appropriate workflow selection)
- [ ] **T4.2**: Performance benchmarking [Source: docs/architecture/workflow-orchestration-testing-plan.md#performance-testing]
  - Establish baseline metrics (pre-optimization)
  - Measure post-optimization improvements
  - Document cost savings achieved
- [ ] **T4.3**: Update workflow documentation [Source: docs/architecture/workflow-orchestration-execution-plan.md]
  - Document new orchestration architecture
  - Create troubleshooting guide for developers
  - Update contribution guidelines

## BDD Scenarios

### Scenario 1: Documentation-Only Changes
```gherkin
Given I push changes containing only ".md" files
When the story orchestrator analyzes the changes
Then no Flutter CI workflows execute
And no expensive validations run
And the process completes in under 2 minutes
```

### Scenario 2: Flutter Code Changes
```gherkin
Given I push changes containing ".dart" files and documentation
When the story orchestrator runs
Then workflow-lint executes first
And preflight-parse runs after lint passes
And flutter-ci runs after preflight passes
And PR creation happens after all validations pass
```

### Scenario 3: Early Failure Prevention
```gherkin
Given I push changes with a YAML syntax error
When workflow-lint runs first
Then the job fails with clear error message
And flutter-ci is never triggered
And no expensive operations are wasted
```

### Scenario 4: Mixed Changes Smart Routing
```gherkin
Given I push changes affecting both workflows and Flutter code
When the orchestrator analyzes changes
Then both workflow-lint and flutter-ci are scheduled
But they run sequentially, not in parallel
And the total execution time is optimized
```

## Testing Strategy

### Automated Tests
1. **Path Filter Testing**: Automated tests for `dorny/paths-filter` configurations
2. **Workflow Simulation**: Use `nektos/act` for local workflow testing
3. **Cost Monitoring**: Automated tracking of GitHub Actions minutes consumption

### Manual Testing
1. **Change Type Validation**: Test each file type category individually
2. **Sequential Execution**: Verify proper job dependency chains
3. **Failure Scenarios**: Test early termination and error propagation

### Performance Testing
1. **Baseline Measurement**: Current workflow execution times and costs
2. **Optimization Impact**: Before/after comparison metrics
3. **Load Testing**: Behavior under multiple concurrent story branches

## Technical Implementation Details

### Path Filter Configuration
```yaml
# .github/workflows/story-orchestrator.yml
- uses: dorny/paths-filter@v2
  id: changes
  with:
    filters: |
      flutter:
        - 'crypto_market/**/*.dart'
        - 'crypto_market/pubspec.yaml'
        - 'crypto_market/pubspec.lock'
        - 'crypto_market/analysis_options.yaml'
      workflows:
        - '.github/workflows/**'
        - '.github/actions/**'
      docs:
        - 'docs/**'
        - '*.md'
      config:
        - 'crypto_market/l10n.yaml'
        - 'crypto_market/dfx.json'
```

### Sequential Execution Pattern
```yaml
jobs:
  analyze-changes:
    outputs:
      run-flutter: ${{ steps.changes.outputs.flutter }}
      run-workflows: ${{ steps.changes.outputs.workflows }}
      run-docs: ${{ steps.changes.outputs.docs }}
  
  workflow-lint:
    needs: analyze-changes
    if: needs.analyze-changes.outputs.run-workflows == 'true'
    
  flutter-ci:
    needs: [workflow-lint, analyze-changes]
    if: |
      always() && 
      needs.analyze-changes.outputs.run-flutter == 'true' &&
      (needs.workflow-lint.result == 'success' || needs.workflow-lint.result == 'skipped')
```

### Concurrency Optimization
```yaml
concurrency:
  group: story-${{ github.ref }}-${{ github.sha }}
  cancel-in-progress: true
```

## Expected Outcomes

### Cost Metrics
- **Phase 1**: 50-60% reduction in GitHub Actions minutes
- **Phase 2**: 70-80% reduction in total workflow execution time
- **Phase 3**: 80-90% optimization with intelligent routing

### Performance Metrics
- **Documentation changes**: 0 workflows (currently 3)
- **Flutter changes**: Sequential execution ~10 minutes (currently 75+ minutes parallel)
- **Workflow changes**: Lint-only ~2 minutes (currently full suite)
- **Mixed changes**: Intelligent partial execution

### Developer Experience
- **Feedback Time**: Reduce from 75 minutes to 10 minutes average
- **Context Switching**: 80% reduction in workflow-related interruptions
- **Predictability**: Clear execution paths and timing expectations

## Risk Assessment

### High Risk
- **Workflow Complexity**: New orchestration layer adds complexity
- **Mitigation**: Comprehensive testing and gradual rollout

### Medium Risk
- **Path Filter Edge Cases**: Unusual file combinations might not trigger correctly
- **Mitigation**: Extensive test scenarios and fallback mechanisms

### Low Risk
- **GitHub API Rate Limits**: Increased workflow_call usage
- **Mitigation**: Built-in GitHub rate limiting and concurrency controls

## Rollback Plan

1. **Phase 1 Rollback**: Restore original trigger configurations
2. **Phase 2 Rollback**: Disable orchestrator, re-enable direct triggers
3. **Phase 3 Rollback**: Remove advanced features, keep basic optimizations
4. **Emergency**: Feature flag to bypass orchestrator entirely

## Change Log

| Date | Version | Description | Author |
| ---- | ------- | ----------- | ------ |
| 2025-08-27 | 0.1 | Initial story creation with comprehensive optimization plan | GitHub Copilot |

## Dev Agent Record

- **Analysis Completed**: 
  - Current workflow inefficiencies identified [Source: docs/github-workflow-optimization-analysis.md]
  - Cost impact calculated (60-70% waste)
  - Technical solution architecture defined [Source: docs/architecture/workflow-orchestration-execution-plan.md]
- **Implementation Plan**:
  - 4-phase approach with measurable milestones
  - Path-based filtering for intelligent workflow selection
  - Sequential execution to prevent resource waste [Source: docs/architecture/workflow-orchestration-execution-plan.md#sequential-execution]
  - Advanced optimizations for maximum efficiency

## QA Results

*Pending implementation and testing*

## Additional: Monitoring & Metrics

### Key Performance Indicators (KPIs)
1. **Workflow Success Rate**: Target >95% (from current ~85%)
2. **Average Execution Time**: Target <10 minutes (from current 75+ minutes)
3. **GitHub Actions Minutes**: Target 70% reduction in daily consumption
4. **Manual Interventions**: Target <2 per week (from current 10-15)

### Monitoring Dashboard
- Real-time workflow execution status
- Cost tracking and optimization recommendations
- Performance trends and regression detection
- Developer impact metrics

### Alerting
- Workflow failure rate above threshold
- Execution time regression beyond 20%
- Cost increase above baseline
- Sequential execution chain breaks

## Success Criteria Summary

✅ **Immediate Impact (Phase 1)**:
- Documentation changes trigger 0 workflows
- 50% reduction in unnecessary Flutter CI runs
- Elimination of redundant push triggers

✅ **Medium-term Impact (Phase 2)**:
- Single orchestrator manages all story branch workflows
- Sequential execution prevents resource waste
- 70% cost reduction achieved

✅ **Long-term Impact (Phase 3)**:
- Intelligent workflow routing based on file changes
- Predictable execution times and costs
- Developer productivity significantly improved
- Automated cost optimization and monitoring

This story represents a significant infrastructure improvement that will benefit all future development work by making our CI/CD pipeline more efficient, cost-effective, and developer-friendly.
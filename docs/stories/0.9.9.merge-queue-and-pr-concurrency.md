Title: Story 0.9.9 — Merge queue and PR concurrency control
Status: Done

# Story 0.9.9: Resolve concurrent PR merges into `develop` with a safe merge queue and conflict‑avoidance rules

## Story

As a repo maintainer, I want to prevent merge races and conflicts when multiple PRs target `develop`, so that merges happen serially, deterministically, and safely with clear queueing and observability.

## Acceptance Criteria

1. Only one PR to `develop` is in the merging phase at a time; additional eligible PRs are queued until the active merge completes (or is cancelled/blocked).
2. Eligibility rules are explicit and enforced:
   - Required checks are green
   - Branch is up‑to‑date with `develop` (auto‑updated if possible, else labeled `needs-rebase` and skipped)
   - For `story/*` branches, label `automerge-ok` is required; for non‑story branches, default allow
3. Ordering is deterministic: FIFO by the time the PR became eligible (first ready, first merged). Ties resolved by PR number ascending.
4. Observability: each run emits a queue summary (current PR, queue length, next candidates) in the job summary; actions are annotated in logs.
5. Safety: if a queued PR receives commits, it is re‑evaluated and its position updated based on new eligibility time; abandoned/blocked PRs are skipped with reason labels/comments.
6. Native GitHub Merge Queue path is supported when available (documented enablement for branch protection); when not available, a fallback controller workflow provides equivalent serialization.
7. Dry‑run mode is available for local/CI testing (e.g., `CI_LOCAL=true`) that prints intended actions without merging.
8. PR watch policy is documented and automated: after pushes, `scripts/watch-pr.sh` is used with standard flags; exit codes are handled consistently (0 merged, 1 closed, 2 needs‑rebase, 124 timeout) and outcomes are logged.

## Dependencies

- 0.9.2 Deterministic PR creation
- 0.9.3 Auto‑merge enablement and repo settings alignment
- 0.9.4 Reliability hardening

## Approaches Considered (and to be supported/documented)

- Native GitHub Merge Queue (preferred when repo settings allow): enable "Require merge queue" on `develop` branch protection; rely on GitHub to serialize merges and update PR heads automatically. [Source: architecture/development-workflow.md#Automation Overview]
- Controller workflow (fallback) — a "poor‑man’s" merge queue:
  - Single controller job acquires a repo‑level lock (concurrency group) per base branch (e.g., `merge-queue-develop`), selects the next eligible PR, updates it if behind, waits for checks, then merges.
  - Queue is implicit: all other contenders wait for the lock; controller re‑runs after base changes to pick the next candidate. [Source: architecture/development-workflow.md#Auto‑merge Gating]
- Policy/rules hardening: require "Status checks must pass on latest commit", require linear history, enforce up‑to‑date via API or label `needs-rebase` with comment instructions. [Source: architecture/development-workflow.md#Agent quick-start]
- Conflict surface reduction (architecture change): minimize hot‑spot files in PRs (e.g., isolate workflow edits to dedicated files, avoid touching shared indices), use CODEOWNERS and feature flags to split risky changes, and encourage smaller, focused PRs per story to reduce overlapping edits. [Source: architecture/coding-standards.md#Workflow & Git]

## Tasks / Subtasks

- [ ] Document native GitHub Merge Queue enablement for `develop` branch protection (screenshots/steps). [Source: architecture/development-workflow.md#Automation Overview]
- [ ] Implement a controller workflow (fallback) to serialize merges when native queue is not enabled:
  - [ ] Create `.github/workflows/merge-queue.yml` (or extend existing fallback) with repo‑level `concurrency: group: merge-queue-${{ inputs.base || 'develop' }}, cancel-in-progress: false`.
  - [ ] Discover eligible PRs via REST: open → base `develop` → mergeable → required labels satisfied; sort FIFO by eligibility time.
  - [ ] For the chosen PR: auto‑update branch if `mergeable_state` is `behind`; if update fails, label `needs-rebase` and skip. [Leverage existing logic in `merge-on-green-fallback.yml`]
  - [ ] Wait for required checks to succeed; then merge (squash) and attempt branch deletion.
  - [ ] Emit a queue summary to `$GITHUB_STEP_SUMMARY` with the processed PR and remaining candidates.
  - [ ] Respect `CI_LOCAL=true` to dry‑run (no merge).
- [ ] Integrate label gates consistently: `automerge-ok` required for `story/*`; default allow for non‑story branches. [Source: architecture/development-workflow.md#Auto‑merge Gating]
- [ ] Add/reuse a lightweight re‑runner trigger (repository_dispatch or workflow_run on PR change) so the controller reevaluates after each merge or base update.
- [ ] Strengthen local guardrails to reduce conflicts pre‑push by keeping branches up‑to‑date; ensure `.git-hooks/pre-push` guidance is referenced in docs. [Source: architecture/development-workflow.md#Agent quick-start]
- [ ] Update docs in `docs/architecture/development-workflow.md` with the queue design, flags, and troubleshooting.
- [ ] Add unit tests for queue selection logic (scripted step), and an integration test plan to simulate 2–3 concurrent PRs.
 - [ ] Document PR watch policy and standard flags in `docs/architecture/development-workflow.md` and link to `scripts/watch-pr.sh`.
 - [ ] Verify Dev/QA/Main Agent rule files reflect standardized watcher invocation and exit‑code handling.

## BDD Scenarios

- Scenario: Two eligible PRs merge in order
  - Given PR #10 and PR #11 both target `develop` and satisfy eligibility
  - When the queue controller runs
  - Then PR #10 is merged first, then PR #11 is updated to latest `develop` and merged

- Scenario: PR behind base and cannot be auto‑updated
  - Given PR #12 is behind `develop` and update via API fails
  - When the queue controller evaluates PR #12
  - Then it labels `needs-rebase`, comments with instructions, and skips to the next PR

- Scenario: PR becomes ineligible while queued
  - Given PR #13 loses `automerge-ok` label after entering queue
  - When the controller reevaluates
  - Then PR #13 is removed from the active position and the next eligible PR proceeds

- Scenario: Watcher detects needs‑rebase
  - Given a PR in queue has label `needs-rebase`
  - When `scripts/watch-pr.sh` runs
  - Then it exits with code 2 and the process instructs a rebase before re‑queuing

## Dev Notes

- Current automation and gating are described here: [Source: architecture/development-workflow.md#Automation Overview], [Source: architecture/development-workflow.md#Auto‑merge Gating]
- Fallback merge and update logic exist in `.github/workflows/merge-on-green-fallback.yml` and should be reused to avoid duplication.
- Local guard `pre-push` already enforces rebasing onto `develop` to minimize conflicts before CI. [Source: architecture/development-workflow.md#Agent quick-start]
- Coding/workflow standards for branches and required checks: [Source: architecture/coding-standards.md#Workflow & Git]
- Testing expectations and pyramid to guide test depth: [Source: architecture/testing-strategy.md#Testing Pyramid]

### Project Structure Notes

- The `unified-project-structure.md` describes a broader monorepo shape; this repository is a Flutter app with CI workflows under `.github/workflows/`. Ensure docs reference the actual paths used here. [Source: architecture/unified-project-structure.md]

## Testing

- Local dry‑run: simulate selection and ordering with `CI_LOCAL=true` and 3 open PRs (mock via REST calls or conditionals) — verify queue summary output.
- Integration (on a test branch): open PRs A, B, C → label per rules → observe serialized merges, branch updates, and final state.
- Negative: inject behind state and permission errors → expect `needs-rebase` label and non‑fatal logging.

## Change Log

| Date | Version | Description | Author |
| ---- | ------- | ----------- | ------ |
| YYYY‑MM‑DD | 0.1 | Initial draft — merge queue and concurrency control story | Scrum Master |
| YYYY‑MM‑DD | 0.2 | Added PR watch policy AC, tasks, and BDD scenario aligned with standardized watcher behavior | Scrum Master |

## Dev Agent Record

- To be populated by Dev during implementation

## QA Results

- To be populated by QA during validation


